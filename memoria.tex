%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX

\title{SimpleRTP: Una biblioteca en Python para enviar MP3 por RTP}
\author{Marcelo Cubría Alonso}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} &
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{UNIVERSIDAD} \\
\Huge
\textsf{REY JUAN CARLOS} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
GRADO EN INGENIERÍA EN SISTEMAS AUDIOVISUALES Y MULTIMEDIA

\vspace{0.4cm}

\large
Curso Académico 2019/2020

\vspace{0.8cm}

Trabajo Fin de Grado

\vspace{2.5cm}

\LARGE
SIMPLERTP: UNA BIBLIOTECA EN PYTHON PARA ENVIAR MP3 POR RTP

\vspace{4cm}

\large
Autor : Marcelo Cubría Alonso \\
Tutor : Dr. Gregorio Robles
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado}

\vspace{1cm}
\large
Título del Trabajo con Letras Capitales para Sustantivos y Adjetivos

\vspace{1cm}
\large
\textbf{Autor :} Marcelo Cubría Alonso \\
\textbf{Tutor :} Dr. Gregorio Robles Martínez

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de marzo de 2020, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de marzo de 2020
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi familia que me ha apoyado en todo momento}
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 

En primer lugar quiero agradecer a mis padres su continuo apoyo, sin el cual habría sido dificil llegar hasta donde estoy ahora. Siempre han buscado lo mejor para mi y han respaldado mis decisiones, dándome consejos que han sido de vital ayuda para las diferentes cuestiones que he afrontado en la vida. Simplemente vale la pena conseguir los logros que te propongas para que ellos sean más felices.

La carrera no habría sido lo mismo sin mis compañeros desde el inicio de esta, que hacían más ameno el madrugón para ir a estudiar. Si bien con el tiempo nos hemos desperdigado por los diferentes cursos y asignaturas, siempre buscamos encontrarnos de vez en cuando para quedar todos como si acabásemos de empezar la carrera.

Gracias también a mis amigos por que sin ellos, nada sería lo mismo. Su apoyo e interés también es una razón para seguir adelante y poder compartir con ellos los buenos momentos. Espero para ellos todo lo bueno que les pueda ocurrir y les ayudaré igual que ellos hicieron.

Y sobre todo gracias a mis abuelos, que al final siempre son los que más se preocupan por sus nietos y quienes más se alegran por su simple presencia. Otro motivo más para luchar al máximo y que puedan ver con sus propios ojos y decir con orgullo lo que su nieto ha hecho.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

En este Trabajo Fin de Grado se desarrolla la biblioteca Python \texttt{SimpleRTP}, que ofrece una interfaz para progarmar aplicaciones (API) sencilla para enviar tráfico RTP (Real-time Transport Protocol) con la configuración a gusto del usuario. Esto permite experimentar con el protocolo y probar las diferentes maneras de enviar paquetes RTP con configuraciones diversas e incluso provocar errores para comprobar los límites de este.

El proyecto nace a partir de las necesidades identificadas en una asignatura de este grado, PTAVI (Protocolos para la Transmisión de Audio y Vídeo por Internet), con la propuesta de desarrollar un programa que cubra las necesidades de incluir de una forma práctica una biblioteca que permita tratar con mayor detalle el protocolo RTP respecto a lo que se hacía hasta el momento. RTP es un protocolo de gran importancia en el intercambio de flujos multimedia. Con las tecnologías que se utilizan con anterioridad en la asignatura no se podía ver su funcionamiento en detalle, limitando las oportunidades en las prácticas de la asignatura. Se busca solucionar esto permitiendo el control total de la cabecera RTP con funciones fáciles de usar, con diferentes grados de complejidad según se necesite.

En este proyecto hay varias tecnologías implicadas, donde las más importantes para el estudio son RTP y MP3, pero se utilizan otras como el lenguaje de programación Python (en su versión 3) para desarrollar el programa y Wireshark como analizador de paquetes en la red para comprobar los resultados.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen en inglés

\chapter*{Summary}
%\addcontentsline{toc}{chapter}{Summary} % si queremos que aparezca en el índice
\markboth{SUMMARY}{SUMMARY} % encabezado

In this undergraduate thesis the \texttt{SimpleRTP} Python library is developed. \texttt{SimpleRTP} offers an application programming interface (API) to send RTP (Real-time Transport Protocol) traffic with a configuration that suits user preferences. This allows to experiment with the protocol and test the different ways of sending RTP packets with a myriad of possible configurations, and even cause errors to check the limits of the program.

The project was born from one of the the subject of this degree, PTAVI (Protocolos para la Transmisión de Audio y Vídeo por Internet - Audio and Video Protocols over the Internet), with the goal of developing a program that covers the needs to include, in a practical way, functions that deal with the protocol in grater detail. RTP is an important protocol in todays multimedia network exchanges, but with the previous set-up it was not possible to see how it works in detail, limiting the scope of the learning. \texttt{SimpleRTP} seeks to solve this by allowing full control of the RTP header with easy-to-use functions, with varying degrees of complexity as needed.

In this project there are various tecnologies involved, being the most relevant RTP and MP3. However, other technologies are used, as the programing lenguage Python --for the development-- or Wireshark, as a packet analyzer in the network to check the results.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INTRODUCCIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Introducción}
\label{sec:intro} % etiqueta para poder referenciar luego en el texto con ~\ref{sec:intro}
\pagenumbering{arabic} % para empezar la numeración de página con números

Este Trabajo Fin de Grado nace de la asignatura Protocolos para la Transmisión de Audio y Video en Internet (PTAVI) y la propuesta de crear para esta un programa con el objetivo de mejorar la forma de enseñar, de manera práctica, el protocolo RTP. Actualmente se utiliza un programa llamado \texttt{mp32rtp} el cual es una caja cerrada, es decir no se ve su funcionamiento de como envía un fichero mp3 a través del protocolo RTP. Esta carencia hace que si bien cumpla su objetivo de enviar paquetes, al usarlo en la asignatura para las prácticas no se pueda utilizar para otros fines como son experimentar y probar las capacidades del protocolo.

Acepté este proyecto por varios motivos. El primero es que deriva de una asignatura que me ha resultado muy interesante y combina varios conocimientos adquiridos en la carrera: programación, protocolos a nivel de red e imagen y sonido. Esto se ajusta a mi gusto por programar a la vez que se tratan contenidos audiovisuales, tan importantes en el grado. El segundo es que es un proyecto que puede tener mucha utilidad, que puede ser utilizado y aprovechado por gente y no ser un proyecto que queda en el olvido. Si cumple con su cometido puede tener un buen fin, que es ayudar a otras personas a estudiar el protocolo RTP de una manera práctica.

La realización de este proyecto contempla varios retos, entre ellos empezar un programa desde cero al no haber una base previa para el propósito del programa y encontrar la forma de que utilizarlo sea a la vez sencillo para cualquier persona pero con el detalle suficiente para estudiar. A lo largo de la memoria se explica en mayor profundidad cada punto anteriormente citado y cómo se ha desarrollado.

\section{Estructura de la memoria}
\label{sec:estructura}

La memoria de este trabajo se divide en diferentes capítulos, resumidos a continuación:

\begin{itemize}
  \item El primer capítulo explica el origen de la iniactiva de este trabajo y el cómo y por qué se ha llevado a cabo.
  
  \item  En el segundo capítulo se expone el objetivo principal que se busca alcanzar y los diferentes objetivos específicos en los que se ha divido para desarrollarlo, incluyendo la planificación temporal que ha supuesto.

  \item En el siguiente capítulo se hace un repaso de las tecnologías implicadas en este proyecto. Desde los protocólos a analizar hasta el lenguaje de programación con el que se ha hecho el programa y herramientas para verificar los resultados.

  \item El cuarto capítulo desarrolla el diseño y la implementación del programa. Con diagramas y blóques de código se explica en profundidad el funcionamiento de todas las funciones de las que se hace uso para enviar paquetes RTP.

  \item En quinto capítulo muestra los diferentes resultados que puede ofrecer SimpleRTP. En este capítulo se incluye la prueba con alumnos que se hizo para poner a prueba el programa.

  \item El apéndice contiene una guía para mostrar cómo se puede usar SimpleRTP en un cliente con diferentes niveles de abstracción, incluyendo un codigo de ejemplo. También se muestra cómo configurar Wireshark para poder ver los resultados de SimpleRTP en este.

  
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OBJETIVOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage % empezamos en página impar
\chapter{Objetivos} % título del capítulo (se muestra)
\label{chap:objetivos} % identificador del capítulo (no se muestra, es para poder referenciarlo)

\section{Objetivo general}
\label{sec:objetivo-general}

El objetivo de este Trabajo de Fin de Grado es crear una biblioteca de envío RTP en Python para su uso didáctico. Esta biblioteca contará con diferentes niveles de complejidad, y permitirá enviar tráfico RTP con los parámetros que el usuario quiera definir. De esta manera se puede analizar el comportamiento del protocolo en diferentes escenarios, comprobando su funcionamiento y capacidades.

El trabajo busca encontrar la manera más amigable y sencilla para el usuario de usar el protocolo RTP para enviar archivos de audio MP3, y ahondar en funciones más complejas según se quiera utilizar en detalle. Para este propósito, me he decidido por crear una biblioteca (que pueda ser utilizada como API).

\section{Objetivos específicos}
\label{sec:objetivos-especificos}

Para llevar a cabo el objetivo general del trabajo, he tenido que realizar diferentes objetivos específicos que en su conjunto han formado el objetivo final. Se pueden diferenciar diferentes fases, listadas a continuación:

\begin{itemize}
  \item Analizar los protocolos implicados en el programa, estudiando cómo están formados los paquetes RTP y MP3 en su cabecera y \emph{payload}. Esta fase es necesaria para entender la función y necesidad de cada campo e identificar aquellos que son importantes para poder tratarlos en el programa.
  
  \item Crear una versión inicial del programa donde el objetivo es integrar los protocolos entre ellos para crear paquetes correctamente, basándose en parámetros introducidos por el usuario. Entender e implementar la manera de manejar los bits que componen la cabecera en Python.
  
  \item Implementar funciones según avanza el programa. Dar más accesibilidad según un modelo API e integrar más funciones a la hora de la utilización añadiendo campos de la cabecera modificables por el usuario.

  \item Verificar el programa con alumnos. Se les ha dado a probar a los alumnos de la asignatura de Protocolos para la transmisión de audio y vídeo en Internet la posibilidad de probar el programa. Con los resultados y sus opiniones ha sido posible mejorar el programa.

  \item Mejorar el programa implementando funciones más sencillas para su uso en función de las pruebas con los alumnos y corregir errores detectados en estas pruebas.
  
\end{itemize}

\section{Planificación temporal}
\label{sec:planificacion-temporal}

Este trabajo de fin de grado empieza en julio de 2019 al plantearse una idea inicial y sus objetivos. Entre agosto y septiembre hago los fines de semana un trabajo de investigación sobre los protocolos y un planteamiento inicial de como plasmar la idea en un programa en Python. También llevo a cabo una búsqueda de programas con un objetivo similar al mío pero sin resultados satisfactorios, por lo que procedo a buscar bibliotecas que puedan ayudarme a empezar. La razón de no poder dedicar más tiempo en estos momentos es por trabajo.

Entre octubre y noviembre desarrollo el programa partiendo de una situación inicial con todos los datos recabados anteriormente.  Al no haber encontrado programas con objetivos parecidos se hace más complicado el desarrollo al tener que escribir todas las funciones de la bibliotca sin base previa. En estos dos meses me reuno varias veces con el tutor Gregorio Robles para revisar el avance y dirigir la biblioteca hacia el objetivo final.

En diciembre la biblioteca ya está acabado con las funcionalidad que se consideran necesarias y se da a probar a los alumnos para poder identificar fallos y puntos de mejora.

En enero de 2020, tras recibir respuesta de los alumnos, identifico en qué ha fallado la biblioteca y en qué ha tenido éxito, y procedo a mejorar el programa y a pulirlo en función a esto.

Entre enero y febrero acabo de pulir y eliminar errores de la biblioteca y escribo la memoria del Trabajo de Fin de Grado, finalizando este mismo.

\begin{figure}[h]
\includegraphics[width=16cm, keepaspectratio]{img/cronograma}
\caption{Planificación temporal del proyecto}
\label{fig:cronograma}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ESTADO DEL ARTE %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Estado del arte - Tecnologías relacionadas}
\label{chap:estado}

En este capítulo se introducen todas las tecnologías implicadas en el desarrollo de este proyecto. Primero se presenta el programa que ha dado pie a SimpleRTP, \texttt{mp32rtp}. Después se encuentra una breve descripción del lenguaje de programación Python, que es el que se ha usado para escribir el programa tanto por ser el lenguaje que más me ha gustado por sus características.

A continuación se describen los diferentes protocolos: RTP y MP3 los más importantes para este proyecto al ser respectivamente la cabecera y el dato útil del paquete que transmite el audio. SDP y SIP son dos protocolos importantes para la transmisión de contenido multimedia por RTP por lo que si bien no son de uso obligatorio para \texttt{SimpleRTP} (se pueden usar otros protocolos con las mismas funciones) se exponen sus funciones principales.

Bitstring es una biblioteca de la que me he servido para manejar de una manera más sencilla los bits que componen las cabeceras de RTP y MP3, al incluir funciones que por defecto no incluye Python.
Wireshark es un conocido analizador de tráfico que resulta de gran ayuda para ver tráfico real generado \texttt{SimpleRTP} y poder analizar el resultado de enviar paquetes RTP y verificarlo.


\section{mp32rtp}
\label{sec:mp32rtp}

El programa \texttt{mp32rtp} es el que se usa en la asignatura PTAVI para transmitir contenido MP3 a través de RTP. Está escrito en el lenguaje de programación C y envía audio MPEG sobre RTP sin que sea necesaria mucha configuración y sin la necesidad de un servidor para transmitir. Puede enviar paquetes a diferentes usuarios con transmisiones unicast, multicast o broadcast.

En las prácticas de la asignatura este programa se usa mediante un comando que se ejecuta desde el propio sistema (llamando a \texttt{os.system}) y en este comando llamando a \texttt{mp32rtp} y pasando como argumentos IP, puerto y fichero de audio. En particular, se especifica que se ha de utilizar un código parecido al siguiente:

\begin{verbatim}
import os

# aEjecutar es un string con lo que se ha de ejecutar en la shell
aEjecutar = "./mp32rtp -i " + receptor_IP + " -p " + receptor_Puerto 
aEjecutar += " < " + fichero_audio

print "Vamos a ejecutar", aEjecutar
os.system(aEjecutar)
\end{verbatim}

\emph{receptor\_IP} y \emph{receptor\_Puerto} son valores que hemos obtenido del cliente (vía \emph{proxy}) mediante la descripción de la sesión (en SDP) y \emph{fichero\_audio} es uno de los parámetros de configuración del \emph{User Agent} guardados en el XML.

El uso docente de \texttt{mp32rtp} plantea varios problemas y limitaciones: por un lado su documentación es bastante pobre, siendo difícil encontrar información en Internet sobre este. Por otro lado y como consecuencia de la pobre documentación, es que no se puede hacer otra cosa con este programa a parte de enviar RTP con los valores que da directamente el programa. El usuario no solo no puede indicar qué parámetros quiere configurar en la cabecera RTP si no que tampoco puede saber a priori cómo se va a enviar el paquete. También hay que tener en cuenta que el programa está escrito en C++, y en particular, en una versión C++ que está desactualizada. Es por eso que el profesor nos lo ofrece como binario, compilado para Debian/Ubuntu para la arquitectura específica de los laboratorios docentes. Aquellos alumnos que utilicen otras arquitecturas (p.ej., los que tienen un Mac) no podrán utilizarlo en sus máquinas. Por último, y no menos importante, el uso de \texttt{mp32rtp} es pedagógicamente pobre: se trata de un parche que posibilita que la práctica funcione, pero no fomenta ni buenas prácticas de programación ni mucho menos el mejor conocimiento del protocolo RTP.


\section{Python}
\label{sec:python}

Python es un lenguaje de programación interpretado cuya filosofía hace hincapié en la legibilidad de su código, creado a finales de la década de los ochenta del siglo pasado por Guido van Rossum~\cite{van2007python}.  Es un lenguaje de programación multiparadigma, lo que significa que la programación puede ser orientada a objetos, imperativa o funcional. Es un lenguaje donde se hace hincapié en la legibilidad del código y en la sencillez, usando palabras donde otros lenguajes usan símbolos y utilizando \emph{indentación} para diferenciar los diferentes bloques de código que incluyen clases, funciones, bucles o condiciones entre otras cosas.

Tiene principios que al cumplirlos el código se considera "pythoniano", entre los cuales destaco:
\begin{itemize}
  \item Explícito es mejor que implícito.
  
  \item Simple es mejor que complejo.
  
  \item Lo práctico gana a lo puro.

  \item Si la implementación es difícil de explicar, es una mala idea.
  
\end{itemize}

Cabe destacar que el proyecto se ha realizado en la versión de Python3 pero que existe una versión anterior llamada Python2. Existen varias diferencias entre las dos pero me he decantado por Python3 por dos motivos fundamentales:

\begin{itemize}

  \item El fín del soporte oficial de Python2 (EOL, End Of Life) se produjo en enero de 2020. Esto significa que no habrá actualizaciones ni corrección de errores desde ese momento.

  \item Python3 es la última versión y actualmente las últimas librerías se están desarrollando para esta, al quedarse obsoleto Python2. También muchas librerías de Python2 no son compatibles con Python3, y ciertas características nativas de Python2 y 3 son diferentes entre ellas haciendo que sean ligeramente incompatibles.
 
\end{itemize}

\section{RTP}
\label{sec:arteRTP}
RTP o Real-time Transport Protocol es un protocolo a nivel de aplicación del modelo OSI utilizado para la transmisión de información audiovisual en tiempo real y end-to-end, descrito en la RFC 1889 como estándar en el año 1996 y actualizado en la RFC 3550 en 2003. Se usa principalmente junto al protocolo UDP de la capa de transporte del modelo OSI, que entre sus características no retransmite paquetes ni cuenta con control de flujo ni de aceptación, siendo un protocolo ideal para las aplicaciones el tiempo real al buscar la velocidad sin preocuparse de la fiabilidad. En las aplicaciones de \emph{streaming} multimedia en tiempo real la pérdida de paquetes es tolerable debido a que la pérdida de un paquete en un paquete de audio es imperceptible con la ayuda de algoritmos para la corrección de fallos.

Una de las características de RTP es la de permitir diferentes formatos multimedia y permitir nuevos formatos sin tener que modificar el protocolo gracias a los perfiles y formatos de \emph{payload}. 

RTP funciona junto a un protocolo asociado a este llamado RTCP o Real-time Transport Control Protocol. Este se usa para enviar periódicamente información de control y parámetros de QoS o calidad de servicio y para sincronizar la sincronización entre las fuentes de flujos multimedia. RTCP consume poco ancho de banda comparado a RTP, alrededor de un 5\%.


\begin{figure}[h]
\includegraphics{img/rtp-header}
\caption{Cabecera de un paquete RTP}
\label{fig:rtp-header}
\end{figure}

\section{SIP y SDP}
\label{sec:SIPSDP}

Si bien este proyecto se centra en RTP y sus funcionalidades, caben destacar dos protocolos utilizados para la transmisión de contenido multimedia por RTP.

Las sesiones RTP donde se encuentran los flujos multimedia se inicializan mediante un protocolo de señalización. Entre ellos se encuentra SIP o Session Initiation Protocol que a su vez puede utilizar SDP o Session Description Protocol.

SIP (RFC 3261~\cite{rosenberg2002rfc3261}) es un protocolo utilizado para iniciar, mantener y finalizar sesiones multimedia en tiempo real. Es un protocolo basado en texto que comparte elementos de HTML y SMTP. Los diferentes end-points que utilizan SIP para comunicarse se llaman User Agents o UA, y actúan como UA Client al hacer una petición o como UA Server al responder a una petición. Otros agentes que actúan en la comunicación SIP son los Proxy Server, que actúan como intermediario y pueden hacer funciones de \emph{routing} o seguridad, y los Registrar, que aceptan peticiones \texttt{REGISTER} de los UA para mantener información sobre este incluyendo su dirección.

SDP (RFC 4566~\cite{handley1998sdp}) es un formato para describir parámetros de sesión en una comunicación multimedia en tiempo real. Entre sus funciones se encuentran los anuncios e invitaciones de sesiones y la negociación de parámetros entre los end-points, que juntos forman el perfil de la sesión. Al igual que SIP, está diseñado para soportar nuevos formatos sin cambiar el formato.

\section {MP3}
\label {sec:mp3}

MP3 o MPEG-1 Audio Layer III (ISO/IEC 13818-3~\cite{isomp3}) es un estándar de comprensión de audio definido en las ISO 11172-3 e ISO 13818-4 y  uno de los formatos de audio común más usados en el mundo. Entre sus características se encuentra una fuerte compresión que causa pérdidas de información pero un menor tamaño de archivo. Las pérdidas provocadas por la compresión sin embargo no son perceptibles al oído humano gracias a modelos psicoacústicos.

Dentro de este estándar los ficheros de audio pueden tener diferente velocidad de bit rate (kbits/s) y de velocidad de muestreo (Hz). Ambos parámetros se definen en la cabecera del paquete MP3 (RFC 5219~\cite{finlaysonrfc5219}).
 
 
\section {Bitstring}
\label {sec:bitstring}

\texttt{Bitstring} es una biblioteca de Python diseñada para facilitar el análisis y procesado de datos en formato binario.

\texttt{Bitstring} \cite{bitstringdoc} define un objeto que se puede construir con variables con una gran variedad de tipos, desde integer big y little endian hasta string, hexadecimal, byte y un proprio binario. 

Los objetos \texttt{Bitstring} tienen diferentes funciones para unir, truncar, adjuntar y escribir el propio objeto y así modificar su contenido en bits. Estos objetos se pueden leer, buscar y reemplazar para poder tratarlos.

Todas estas características han resultado útiles para la lectura, manejo y creación de cabeceras en formato binario, tanto para las de RTP como para las de MP3.

\section{Wireshark}
\label{sec:wireshark}

Wireshark \cite{wiresharkdoc} es un analizador de protocolos de red que permite analizar a muy bajo nivel todos los paquetes que pasan por la red, disponible para una gran cantidad de plataformas.

Tiene integrados una gran cantidad de protocolos en continuo aumento que permite detectarlos y analizar sus cabeceras y permite capturar tráfico en tiempo real o analizar capturas guardadas para un análisis posterior. También analiza exhaustivamente tráfico de VoIP (Voice over IP). Puede filtrar el tráfico en base a protocolos o a parámetros decididos por el usuario para tener una captura limpia solo con el tráfico que interesa.

Todas estas características son interesantes y han ayudado mucho a comprobar el funcionamiento del programa al poder ver en detalle los paquetes RTP enviados y sus cabeceras, comprobando que todos los campos que el usuario indicaba al llamar a las funciones se veían reflejados en tráfico real.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% DISEÑO E IMPLEMENTACIÓN %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Diseño e implementación}

\section{Arquitectura general} 
\label{sec:arquitectura}

El programa está desarrollado como una biblioteca ofreciendo una API, lo que significa que sirve para dar funciones y procedimientos a otro software sin que este se tenga que preocupar del funcionamiento interno de las funciones utilizadas. Esta capa de abstracción hace que el uso sea más fácil para el usuario. En el caso de SimpleRTP, se ofrecen diferentes niveles de abstracción con el objetivo de poder profundizar en las opciones del programa.

El programa cliente emisor debe importar la biblioteca SimpleRTP para poder abrir una conexión UDP y enviar paquetes RTP, mientras que un posible programa receptor que escuche en el puerto objetivo no necesita importarla.

En la figura~\ref{fig:flowchart}, se muestra un diagrama del funcionamiento del programa con los diferentes agentes que participan en el proceso del envío de paquetes.

\begin{figure}[h]
\includegraphics{img/Flowchart}
\caption{Funcionamiento del programa en su conjunto.}
\label{fig:flowchart}
\end{figure}


\section{SimpleRTP}
\label{sec:simplertp}


\subsection{RtpHeader}
\label{sec:rtpheader}

El componente fundamental de este programa es la clase RtpHeader. Un objeto RtpHeader contiene todos los valores que forman una cabecera RTP y es indispensable crear un objeto para el envío de paquetes RTP. Tiene varias funciones con diversos propósitos que se detallarán a continuación. El diagrama que representa el flujo de funcionamiento de la clase se puede observar en la Figura~\ref{fig:rtpheader}.

\begin{figure}[h]
\includegraphics{img/diagrama-rtpheader}
\caption{Diagrama de funcionamiento de la clase RtpHeader}
\label{fig:rtpheader}
\end{figure}


\subsubsection{Init}

Al crearse el objeto se ejecuta la función Init:

\begin{verbatim}
def __init__(self, version=2, pad_flag=0, ext_flag=0, cc=0, marker=0,
             payload_type=14, ssrc=1000):
        self.seq_number = random.randint(1, 10000)  # Aleatorio
        self.timestamp = random.randint(1, 10000)  # Aleatorio
        self.set_header(version, pad_flag, ext_flag, cc, marker, 
                        payload_type, ssrc)
\end{verbatim}

Todos los argumentos con los que se crea un objeto son opcionales y tienen valores por defecto, por lo que no es necesario para un uso básico usar ninguno. Por defecto se define un número de secuencia y timestamp aleatorios (impredecibles) para reforzar la seguridad y evitar ciertos ataques que se basan en estos valores. Estos dos valores se guardan en variables para su uso más adelante.

La función Init llama a la siguiente función que también puede llamar el usuario, set header. Su lógica detrás de esto es que con una sola línea y sin argumentos ni variables se pueda crear una cabecera RTP completa. Los argumentos que se hayan pasado al crear el objeto (si se han pasado, si no los valores por defecto) se utilizan para llamar a set header.

\subsubsection{Set header}

Esta función puede ser invocada por el usuario o al final de la función Init:

\begin{verbatim}
def set_header(self, version=2, pad_flag=0, ext_flag=0, cc=0, marker=0, 
               payload_type=14, ssrc=1000):
        self.version = BitArray(uint = version, length = 2)
        self.pad_flag = BitArray(uint = pad_flag, length = 1)
        self.ext_flag = BitArray(uint = ext_flag, length = 1)
        
        self.cc = BitArray(uint = cc, length = 4)
        self.marker = BitArray(uint = marker, length = 1)
        self.payload_type = BitArray(uint = payload_type, length = 7)
        self.ssrc = BitArray(uint = ssrc, length = 32)
        self.csrc = BitArray()
\end{verbatim}

Todos los valores que se pasen a set header se guardan en variables dentro del objeto. Cada variable es un campo de la cabecera RTP y se guardan con un tipo BitArray. Este tipo se importa de la biblioteca \texttt{Bitstring} y pasado un valor de tipo integer y la longitud en bits se genera un número binario con ciertas características que le da el ser del tipo BitArray, entre ellas operaciones y poder unirse o separarse con otros BitArray.

\subsubsection {Funciones específicas}

A continuación las funciones específicas que modifican un solo campo de la cabecera RTP y se pueden invocar desde el cliente:

\begin{verbatim}
    def setVersion(self, version):
        self.version = BitArray(uint = version, length = 2)

    def setPaddingFlag(self, pad_flag):
        self.pad_flag = BitArray(uint = pad_flag, length = 1)

    def setExtensionFlag(self, ext_flag):
        self.ext_flag = BitArray(uint = ext_flag, length = 1)

    def setCsrcCount(self, cc):
        self.cc = BitArray(uint = cc, length = 4)

    def setMarker(self, marker):
        self.marker = BitArray(uint = marker, length = 1)

    ...

\end{verbatim}

La unica función algo diferente es la que guarda el valor de los identificadores CSRC. Cada valor CSRC forma parte de un array que es el argumento de la función, y uno a uno se convierten a valores binarios y se concatenan.

\subsubsection{Next}

Esta función no se recomienda ser invocada por el usuario, y por eso su nombre empieza con un guión bajo tal y como es práctica común en Python (un lenguaje de programación que carece de métodos privados). Se invoca automáticamente cada vez que se envía un paquete RTP y aumenta el valor del número de secuencia en 1 y el valor del timestamp en función del tiempo de duración de un frame MP3 en milisegundos.

\begin{verbatim}

def _next(self, frameTimeMs):
        self.seq_number += 1
        # Calcular siguiente timestamp
        self.timestamp += int(8000 * (frameTimeMs/1000))

\end{verbatim}

\subsection{RtpPayloadMP3}
\label{sec:rtppayloadmp3}

Una vez tenemos en un objeto todo lo necesario para formar la cabecera de un paquete RTP, el siguiente paso es el \emph{payload} o la carga útil del paquete. Aquí es donde se encuentra el paquete MP3. Un fichero MP3 es una sucesión continua de paquetes por lo que es necesario localizar la cabecera de cada paquete y analizarla para ver sus cualidades como el tiempo de muestreo o los bits por segundo.

La clase RtpPayloadMP3 tiene dos funciones. La primera, init, es la que se llama al crear un objeto de la clase y la segunda, llamada \_take\_mp3\_frame es la encargada de analizar el paquete. El diagrama que representa el flujo de funcionamiento de la clase es el que se puede ver en la Figura~\ref{fig:payload}.

\begin{figure}[h]
\includegraphics[width=17cm]{img/diagrama-mp3payload}
\caption{Diagrama de funcionamiento de la clase RtpPayloadMP3}
\label{fig:payload}
\end{figure}



\subsubsection{init}
Al crear un objeto se llama a la función Init. El objetivo de esta función es manejar el fichero de audio MP3 que se le pasa, pasarlo a binario y encontrar el inicio de la primera cabecera:

\begin{verbatim}
def __init__(self, file_path):
        with open(file_path, "rb") as file:
            bytes = file.read()
            self.bits = BitArray(bytes).bin
            self.header_index = self.bits.find('11111111111')
\end{verbatim}

El fichero se pasa a binario para poder trocearlo en paquetes e indexar el inicio de cada uno para pasarlos como subarrays del fichero. El inicio de la cabecera se encuentra buscando la secuencia de once '1's seguidos y se guarda el índice donde empieza esta serie de números en una variable. Más adelante se comprueba que estos forman parte de la cabecera y no del \emph{payload}.

\subsubsection{\_take\_mp3\_frame}

Cuando se invoca a esta función, se analiza el siguiente paquete que se vaya a enviar. A partir del índice del inicio del paquete se cogen los siguientes 32 bits, los correspondientes al tamaño de la cabecera. Los valores más importantes son los llamados 'version', 'bitrate' y 'sampling'. El campo 'layer' debería indicar siempre '01' que significa Layer III.

El campo version (en inglés) de dos bits indica si nos encontramos ante un paquete MPEG1, MPEG2 o MPEG2.5. Sabiendo la versión del paquete se analizan los valores de 'bitrate' y 'sampling' para, con estos tres valores, acceder a los diccionarios que contienen los valores de bps y frecuencia de muestreo. Esto se hace porque los valores de 'bitrate' y 'sampling' son valores binarios que no tienen ningun valor en decimal, si no que hay que asociarlos a los valores del diccionario.

Con estos valores podemos calcular el tamaño en bits del paquete, y por lo tanto guardar el paquete en una variable e identificar donde empieza el siguiente.

A continuación una parte de la función donde se ven los últimos pasos:

\begin{verbatim}
        frame_length = int(144 * 8 * (bps/sample_rate))
        # tiempo por frame en milisegundos
        self.frameTimeMs = int(144/sample_rate * 1000 * 8)
        next_mp3_header_index = self.header_index + frame_length
        self.frame = self.bits[self.header_index:next_mp3_header_index]
        self.header_index = next_mp3_header_index
\end{verbatim}




\subsection{send\_rtp\_packet}
\label{sec:sendrtppacket}

La función send\_rtp\_packet es la encargada de juntar las diferentes partes que componen el paquete RTP completo y enviar el paquete mediante un socket UDP. En esta función es donde se define el número de paquetes RTP que se quieren enviar y la cantidad de paquetes MP3 en cada paquete RTP.

El diagrama que representa el flujo de funcionamiento de la función se muestra en la figura~\ref{fig:sendpacket}.

\begin{figure}[h]
\includegraphics[width=17cm]{img/diagrama-sendpacket}
\caption{Diagrama de funcionamiento del envío de paquetes RTP mediante send\_rtp\_packet.}
\label{fig:sendpacket}
\end{figure}


Tras abrir el socket UDP con la dirección indicada, se empiezan a enviar paquetes RTP en bucle. El paquete que se envía se forma juntando los diferentes campos que contiene el objeto RtpHeader en orden y tras esto se juntan al final el número de paquetes MP3 indicados, que forman el \emph{payload} del paquete final. Cada vez que se añade un paquete MP3 se llama a la función \_take\_mp3\_frame que es la encargada de identificar el siguiente paquete. 

Una vez formado el paquete se convierte a bytes y se envía. Después se aumentan los valores de número de secuencia y timestamp RTP para prepararse para enviar el siguiente paquete.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% RESULTADOS %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Resultados y pruebas}

\section{Resultados en Wireshark}
\label{sec:reswireshark}

El objetivo de SimpleRTP es el envío de paquetes RTP. Para comprobar que los paquetes se envian correctamente me ha ayudado la herramiente \texttt{Wireshark}. Con \texttt{Wireshark} es posible analizar los paquetes RTP en profundidad y comprobar que se ha formado el paquete correctamente con todos los campos correspondientes.

La primera prueba para verificar los resultados la realizo usando SimpleRTP de la manera más simple posible, utilizando el ejemplo de mayor nivel de abstracción de los apartados anteriores. Podemos ver el resultado en la figura \ref{fig:wireshark-1}.

Se puede observar que el primer paquete RTP tiene un número de secuencia y timestamp que no empiezan en 0, y que en cada paquete aumentan sus valores. Todos los paquetes tienen el mismo tamaño, ya que todos tienen en su \emph{payload} el mismo número de paquetes MP3 y las cabeceras son iguales.

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/wireshark-1}
  \caption{Envío de paquetes RTP en \texttt{Wireshark}.}
  \label{fig:wireshark-1}
\end{figure}

Al enviar paquetes de esta manera, los valores que toma la cabecera son todos por defecto. Esto significa que tenemos los siguientes valores: 

\begin{verbatim}
    version = 2
    pad_flag = 0
    ext_flag = 0
    cc = 0
    marker =  0
    payload_type = 14
    ssrc = 1000
\end{verbatim}

Podemos comprobar al analizar la cabecera RTP del paquete en \texttt{Wireshark} que todos los valores son correctos en la figura \ref{fig:wireshark-2}. Un primer indicio de que todo ha ido bien es que el propio \texttt{Wireshark} reconoce el protocolo RTP, por lo que el paquete parece estar bien formado.
También se puede observar el tamaño del paquete. Este tamaño depende del \emph{payload} y en este caso son 2 paquetes MP3 por RTP, que es el valor por defecto ya que no hemos indicado nada.

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/wireshark-2}
  \caption{Cabecera de un paquete RTP con valores por defecto}
  \label{fig:wireshark-2}
\end{figure}

El siguiente paso es poner a prueba el programa enviando paquetes usando el ejemplo de nivel de abstracción medio. Aquí se hace uso de una función específica para un campo y se pasa un argumento también a la función set\_header. También voy a cambiar el número de paquetes MP3 en cada paquete RTP a 3 para poder ver el cambio del tamaño del paquete final. Capturando el tráfico obtenemos el siguiente resultado reflejado en las figuras \ref{fig:wireshark-3} y \ref{fig:wireshark-4}.

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/wireshark-3}
  \caption{Otro envío de paquetes RTP. Se puede observar los primeros valores de timestamp y número de secuencia diferentes.}
  \label{fig:wireshark-3}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/wireshark-4}
  \caption{Cabecera de un paquete RTP con CSRCs indicados por el cliente}
  \label{fig:wireshark-4}
\end{figure}

Lo primero que se puede notar es que el tamaño de los paquetes ha cambiado. Esto no se debe solo al mayor \emph{payload}, al haber 3 paquetes MP3 encapsulados en vez de 2, si no también a la inclusión de 4 CSRCs en la cabecera RTP que no estaban antes. Cada ID de un CSRC ocupa 32 bits o 4 bytes más en la cabecera.

En el detalle de la cabecera RTP, casi todos los campos siguen tomando los valores por defecto, menos el CC (ya que al final es la cantidad de CSRCs presentes en la cabecera) y los nuevos CSRCs. Podemos comprobar que todos los valores son correctos, ya que o son los indicados por el programa cliente o son los valores tomados por defecto. Los valores que toman los CSRCs se muestran en hexadecimal, pero son correctos al corresponderse a 2000, 3000, 4000 y 5000 en decimal respectivamente.

Otra prueba es cambiando más campos a la cabecera RTP pasando valor a todos los campos, como en el ejemplo de menor nivel de abstracción, pero dejando algunos valores iguales que los de por defecto. Este último cambio lo hago en el último ejemplo ya que asignar valores sin sentido a los campos de la cabecera provocará errores. En la figura \ref{fig:wireshark-5} podemos ver la cabecera con más cambios y con otro tamaño de paquete para comprobar los cambios de tamaño de \emph{payload}, habiendo ahora un paquete MP3 encapsulado.

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/wireshark-5}
  \caption{Cabecera de un paquete RTP con todos los valores asignados desde el programa cliente.}
  \label{fig:wireshark-5}
\end{figure}

En esta captura se comprueba que todo sigue funcionando correctamente con los nuevos valores que hemos indicado. A continuación una última prueba en la que cambiamos todos los campos indiscriminadamente, sin atender realmente al significado que puede tener un 0 o un 1 en los indicadores de extensión o padding. El unico campo que no voy a cambiar para estos ejemplos es el de versión, porque 	exttt{Wireshark} deja de reconocer el protocolo del paquete como RTP y no podemos analizar las cabeceras. El resultado de esta ejecución se ve en la figura \ref{fig:wireshark-6}.

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/wireshark-6}
  \caption{Cabecera de un paquete RTP con todos los valores asignados desde el programa cliente y con errores.}
  \label{fig:wireshark-6}
\end{figure}

En esta prueba podemos ver el problema desde el primer momento al indicar \texttt{Wireshark} que el paquete está mal formado. Sigue reconociendolo como un paquete RTP al no haber tocado la versión y por esto mismo entiende el resto de campos y concluye que algo hay mal. En este caso el cliente ha decidido indicar que los campos que indican que hay padding y extensión se activan, pero realmente la cabecera no tiene estos campos. Este ejemplo sirve para demostrar que se pueden provocar errores intencionadamente con SimpleRTP para ver como estos paquetes mal formados se comportan en la red.


\section{Pruebas con alumnos}
\label{sec:pruebas}

Para poner a prueba el programa, se le proporcionó una versión \emph{beta} a los alumnos de la asignatura de 'Protocolos para la transmisión de audio y vídeo en Internet' del grado de Ingeniería en sistemas audiovisuales y multimedia. El objetivo era comprobar el grado de funcionamiento del programa expuesto a varias pruebas hechas por otras personas y analizar si el programa lograba su objetivo de ofrecer una manera fácil de usarse para propósitos educativos.

Tras dar un tiempo a los alumnos para integrar SimpleRTP en su práctica de la asignatura, se han podido identificar varios puntos a cambiar. Al analizar el código que usaron los alumnos, se pudo ver que no supieron entender como integrar este programa con el que ya tenían, ya que combinaban el método que utilizaban antes para enviar paquetes RTP con la biblioteca de SimpleRTP.

Debido a esto, trabajé en hacer niveles de complejidad menores que derivaron en el nivel de abstracción mayor que detallé en el apartado anterior. Con esto se busca que no sea necesario comprender en profundidad el programa ni el funcionamiento de RTP, haciendo lo más fácil posible enviar paquetes. Otros fallos identificados gracias a las capturas enviadas por una alumna eran fallos menores del programa que corregí gracias a las pruebas, como por ejemplo la inclusión de los diccionarios con diferentes bps y frecuencias de muestreo para todos los tipo de ficheros de MP3. Gracias a esto SimpleRTP soporta más tipos de ficheros MP3 y es más robusto frente a este tipo de errores.
Se puede ver el uso de SimpleRTP junto al otro método en la figura \ref{fig:uaclient.py}.

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/uaclient.png}
  \caption{Uso por una alumna de SimpleRTP.}
  \label{fig:uaclient.py}
\end{figure}


Aún con los fallos que puedo encontrar esta alumna, el envío de paquetes RTP mediante este programa fue satisfactorio, como se puede observar en una captura en \texttt{Wireshark} donde se aprecia un paquete con los parámetros que indicó usando las funciones de la biblioteca SimpleRTP.

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/wiresharkRTP}
  \caption{Captura de paquetes RTP enviados con SimpleRTP por una alumna.}
  \label{fig:wiresharkRTP}
\end{figure}

Por lo tanto, considero que el mayor problema fue entregar el programa con solo funcionalidades de nivel de abstracción bajo y que los alumnos no pudieron interpretar bien el funcionamiento del programa, al combinar el uso de este con el envío de paquetes de otras maneras. En cambio, pude comprobar el correcto funcionamiento de este al ver en la captura de \texttt{Wireshark} el envío de paquetes RTP mediante las funciones de SimpleRTP.





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}


\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

Es importante análizar si se han cumplido los objetivos del trabajo y en qué grado para concluir si se ha llevado a cabo satisfactoriamente. El fin para el que he hecho este programa es para ser usado por un estudiante o una persona que quiera poner a prueba el protocolo RTP para estudiarlo y comprenderlo de mejor manera y, si es posible, que se utilice en la asignatura de PTAVI para sustituir el programa que se estaba utilizando para el envío de RTP, ya que SimpleRTP ofrece mejores funcionalidades a la hora de aprender.

Respecto a este último punto, no será posible ver los verdaderos resultados hasta que se use en la asignatura el próximo curso y que se pueda ver su efectividad real con una mayor base de usuarios. Relacionado con los alumnos está la prueba que se hizo con los de este curso, a los que se les dió la posibilidad opcional de probar el programa en una práctica. Es cierto que esperaba una mayor participación, al haberlo utilizado solo dos alumnos, pero los resultados obtenidos no obstante me han servido de gran ayuda para corregir errores e identificar puntos a mejorar. Por lo tanto podría concluir que, aunque pueda parecer una baja participación, los resultados han sido útiles y por lo tanto considerar satisfactoria la prueba.

Los objetivos intermedios necesarios para llevar a cabo el trabajo han sido, como comenté en el capítulo 2, la adquisición de conocimiento teórico sobre los protocolos a tratar y el planteamiento desde cero de como programar lo que buscaba. Considero que estos objetivos los he llevado a cabo con éxito, ya que para poder enseñar algo y conseguir que se aprenda hay que entenderlo primero, y si la tarea de programación consigue que algo de mayor complejidad se vuelva simple es porque he entendido a fondo como funcionan los diferentes factores involucrados.

Puedo concluir este apartado con que he logrado los objetivos propuestos pero con un rango de mejora que comento más adelante.

\section{Conocimientos aplicados}
\label{sec:conocimientos-aplicados}

Para llevar a cabo el programa SimpleRTP me han sido de gran ayuda varias asignaturas del Grado en Ingeniería en Sistemas Audiovisuales y Multimedia, que me han aportado el conocimienton necesario para poder plantear y desarrollar el programa y para solventar los problemas que hayan podido surgir durante el trascurso.

Sin duda la asignatura fundamental sobre la que se basa este trabajo es la asignatura Protocolos para la Transmisión de Audio y Video en Internet. Con esta asignatura conocí el protocolo RTP y los asociados como SIP y SDP, base del programa que he desarrollado y donde más he profundizado. Otro conocimiento fundamental que he adquirido en esta asignatura es el lenguaje de programación Python, importante no solo para este trabajo o la asignatura si no para el futuro al ser un lenguaje importante y con mucho potencial.

Aunque haya sido la asignatura sobre la que he basado el programa, las conocimientos de las asignaturas de los años anteriores son necesarios para llegar al nivel de conocimiento que requiere PTAVI. Las asignatura Informática I fue la puerta de entrada al mundo de la programación e Informática II me propuso retos más complicados que consiguieron que aumentase mucho mi nivel programando. Que todas las asignaturas de programación se impartiesen con diferentes lenguajes también me ayudó a saber adaptarme y no limitarme a uno solo.

Aún habiendo citado estas asignaturas en concreto, considero que todas las asignaturas del grado me han servido para desarrollarme como estudiante y como persona, y por lo tanto en el resultado de este Trabajo Fin de Grado. Hay asignaturas que han podido resultarme más sencillas por haber captado mi interés y coincidir con mis gustos y otras en las que he tenido que dedicar mucho más tiempo para poder absorber los conocimientos que quiere transmitir, pero al final todas de un modo u otro me han hecho enfrentarme a problemas que en su totalidad han constituido un reto que he conseguido superar. Mirando atrás desde que empecé el grado veo que cuando en su momento dudé con alguna asignatura, ahora veo su utilidad.



\section{Futuros trabajos}
\label{sec:futuros-trabajos}

Como he dicho el programa tiene un amplio rango de mejora, con funcionalidades adicionales que pueden dar más versatilidad y contenido al programa. Mi plan de futuro con este programa es poder mejorarlo según requiera la situación y cuando se puedan ver las necesidades cuando lo utilicen más alumnos.

\begin{itemize}
  \item Entre las nuevas funcionalidades que se pueden incluir se encuentra todo lo relativo al protocolo RTCP, donde se pueden añadir funciones como las que pertenecen a la cabecera RTP para poder controlar todo el contenido del protocolo. 
  
  \item También me gustaría añadir más codecs de audio. Si bien es una opción que investigué en su momento, hay varios protocolos que son de empresas donde la información pública es mucho más limitada y su inclusión en este proyecto excluí por las complicaciones que aportaba y porque el protocolo MP3 es ampliamente el más utilizado y suficiente para transmitir paquetes RTP, que es la función final del programa.
  
\end{itemize}

Todo se puede mejorar y estoy dispuesto a ello, empezando por las mejoras que ya he identificado y siguiendo por todas aquellas que identifiquen los usuarios, ya que las necesidades reales surgen cuando lo utilizan los clientes finales.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{Manual de usuario}
\label{app:manual}

El programa cliente puede tener cualquier propósito y diferentes implementaciones. Para el uso de SimpleRTP es necesario importar la biblioteca y también tener la biblioteca de bitstring.

Existen diferentes niveles de abstracción, desde el nivel más abstracto en el que no es necesario indicar nada sobre el protocolo RTP y solo hay que pasar un fichero MP3, hasta el nivel donde podemos elegir todos los campos de la cabecera RTP, el tamaño del \emph{payload} del paquete y la cantidad de paquetes que queremos enviar.

\section{Mayor nivel de abstracción}
\label {sec:mayor-abs}

Un ejemplo de uso de SimpleRTP con el mayor nivel de abstracción es el siguiente:

\begin{verbatim}
     cabeceraRTP = simplertp.RtpHeader()
     audio = simplertp.RtpPayloadMp3('fichero.mp3')

     ip = '127.0.0.1'
     port = 33332

     simplertp.send_rtp_packet(cabeceraRTP, audio, ip, port)
\end{verbatim}


La primera línea crea una variable que contiene un objeto RtpHeader. Crear un objeto sin pasar ningún parámetro deja la cabecera con valores por defecto.

En la segunda también tenemos una variable que contiene un objeto, en este caso de la clase RtpPayloadMp3. Para crear este objeto es necesario pasar el path donde se encuentra el fichero a enviar.

Las siguientes dos líneas son variables para indicar IP y puerto de destino donde se abrirá el socket UDP, por lo que no dependen directamente de SimpleRTP y simplemente se podrían incluir sus valores en la siguiente línea.

La última línea es donde se envían los paquetes. La función\begin{verbatim} send_rtp_packet \end{verbatim}necesita mínimo todos los argumentos que hemos definido anteriormente: una objeto RtpHeader, un objeto RtpPayloadMp3 y una IP y puerto destino. Sin más argumentos opcionales, el tamaño de \emph{payload} y el número de paquetes enviados toma un valor por defecto.

\section{Nivel medio de abstracción}
\label{sec:media-abs}

Entrando algo en detalle se pueden empezar a modificar campos de la cabecera RTP y el tamaño de los paquetes:

\begin{verbatim}
     csrc = [2000, 3000, 4000, 5000]
     cabeceraRTP = simplertp.RtpHeader(cc=len(csrc))
     cabeceraRTP.setCSRC(csrc)

     audio = simplertp.RtpPayloadMp3('archivo.mp3')

     numeroPaquetesRTP = 0
     paquetesMP3porRTP = 2

     ip = '127.0.0.1'
     port = 33332

     simplertp.send_rtp_packet(cabeceraRTP, audio, ip, port, paquetesMP3porRTP, numeroPaquetesRTP)

\end{verbatim}

En este caso al crear el objeto RtpHeader pasamos un argumento, el de la cuenta de número de fuentes contribuyentes. Se pueden pasar todos los argumentos que se quieran al crear el objeto dentro de los que existen, representando cada uno a un campo de la cabecera RTP.  Cuando creamos el objeto, todos los argumentos que no se pasen toman valores por defecto.

Otra manera de definir campos de la cabecera es mediante funciones específicas para cada campo como setCSRC que define los identificadores de cada fuente contribuyente.

En la llamada a sendrtppacket se pasan dos nuevos argumentos, paquetesMP3porRTP y numeroPaquetesRTP. Esto permite elegir el número de paquetes MP3 que contiene un solo paquete RTP aumentando así el tamaño del \emph{payload} RTP. El segundo argumento nos permite elegir cuantos paquetes RTP queremos enviar con la llamada. Esto permite no enviar todo el archivo y cambiar parámetros RTP y enviar más paquetes después si así se desea.


\section{Menor nivel de abstracción}
\label{sec:menor-abs}

En el menor nivel de abstracción que ofrece SimpleRTP podemos modificar todos los campos de la cabecera RTP junto al tamaño del \emph{payload} del paquete y los paquetes enviados.

\begin{verbatim}

    cabeceraRTP = simplertp.RtpHeader()
    csrc = [2000, 3000, 4000, 5000]
    cabeceraRTP.set_header(version=2, pad_flag=0, ext_flag=0, cc=4, 
                           marker=0, \emph{payload}_type=14, ssrc=1000)
    cabeceraRTP.setCSRC(csrc)
    audio = simplertp.RtpPayloadMp3('archivo.mp3')
    numeroPaquetesRTP = 0
    paquetesMP3porRTP = 2
    ip = '127.0.0.1'
    port = 33332
    simplertp.send_rtp_packet(cabeceraRTP, audio, ip, port,  
                              paquetesMP3porRTP, numeroPaquetesRTP)

\end{verbatim}

En este ejemplo se usa una nueva función llamada setheader. Esta función pertenece al objeto RtpHeader y permite cambiar en una línea todos los campos de la cabecera. Siguen estando las funciones para cambiar solamente campos específicos. 

En este nivel por lo tanto se pueden modificar todos los campos de la cabecera RTP de diferentes maneras y controlar el tamaño del \emph{payload} y el número de paquetes.

\section {Wireshark}
\label{sec:manual-wireshark}

Para analizar el tráfico generado se entiende que el usuario tiene un conocimiento básico de Wireshark y sabe capturar paquetes y analizar el contenido de cada uno. Sin embargo, incluyo este apartado para explicar cómo ver tráfico RTP en Wireshark ya que normalmente esta opción está desactivada por defecto y por lo tanto no se podría ver la cabecera RTP con sus contenidos.

Por defecto enviando tráfico RTP veremos en Wireshark algo parecido a la figura \ref{fig:wireshark-udp}:

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/wireshark-udp}
  \caption{Wireshark sin analizar paquetes RTP.}
  \label{fig:wireshark-udp}
\end{figure}

Como se puede observar, todo el tráfico se ve como UDP (el protocolo que utiliza el socket) pero nada de RTP. Si analizamos un paquete, vamos que contiene un gran payload pero lo clasifica como "data" y no interpreta nada.

La solución a esto es la siguiente: desde la interfaz de Wireshark, ir a 'Analyze' en la barra superior y después a 'Enabled protocols'. Ahí debemos buscar RTP y activar 'rtp\_udp' como podemos ver en la figura \ref{fig:wireshark-sol}.

\begin{figure}
  \centering
  \includegraphics[width=16cm, keepaspectratio]{img/wireshark-sol}
  \caption{Casilla a activar para poder ver tráfico RTP.}
  \label{fig:wireshark-sol}
\end{figure}

Una vez activado, se podrán ver las capturas como en las imágenes de los apartados anteriores.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{apalike}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/

\end{document}
